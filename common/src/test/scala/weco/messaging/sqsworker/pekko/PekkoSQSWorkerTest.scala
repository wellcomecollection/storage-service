package weco.messaging.sqsworker.pekko

import java.net.SocketTimeoutException

import org.scalatest.concurrent.{
  AbstractPatienceConfiguration,
  Eventually,
  ScalaFutures
}
import org.scalatest.funspec.AnyFunSpec
import org.scalatest.matchers.should.Matchers
import org.scalatest.time.{Millis, Seconds, Span}
import weco.pekko.fixtures.Pekko
import weco.json.JsonUtil._
import weco.messaging.fixtures.SQS.QueuePair
import weco.messaging.fixtures.monitoring.metrics.MetricsFixtures
import weco.messaging.fixtures.worker.PekkoSQSWorkerFixtures
import weco.messaging.worker.models.TerminalFailure

import scala.concurrent.ExecutionContext.Implicits.global

class PekkoSQSWorkerTest
    extends AnyFunSpec
    with Matchers
    with PekkoSQSWorkerFixtures
    with MetricsFixtures
    with ScalaFutures
    with Eventually
    with AbstractPatienceConfiguration
    with Pekko {

  override implicit val patienceConfig: PatienceConfig =
    PatienceConfig(
      timeout = scaled(Span(30, Seconds)),
      interval = scaled(Span(150, Millis))
    )

  val namespace = "PekkoSQSWorkerTest"

  describe("When a message is processed") {
    it("consumes a message and increments success metrics") {
      withLocalSqsQueuePair() {
        case QueuePair(queue, dlq) =>
          withActorSystem { implicit actorSystem =>
            withPekkoSQSWorker(queue, successful, namespace) {
              case (worker, _, metrics, callCounter) =>
                worker.start

                val myWork = MyWork("my-new-work")

                sendNotificationToSQS(queue, myWork)

                eventually {
                  callCounter.calledCount shouldBe 1

                  assertMetricCount(
                    metrics = metrics,
                    metricName = s"$namespace/Successful",
                    expectedCount = 1
                  )
                  assertMetricDurations(
                    metrics = metrics,
                    metricName = s"$namespace/Duration",
                    expectedNumberDurations = 1
                  )

                  assertQueueEmpty(queue)
                  assertQueueEmpty(dlq)
                }
            }
          }
      }
    }

    it("processes lots of messages") {
      val works = (1 to 20).map { i =>
        MyWork(s"my-work-$i")
      }

      withLocalSqsQueuePair() {
        case QueuePair(queue, dlq) =>
          withActorSystem { implicit actorSystem =>
            withPekkoSQSWorker(queue, successful, namespace) {
              case (worker, _, metrics, callCounter) =>
                worker.start

                works.foreach { sendNotificationToSQS(queue, _) }

                eventually {
                  callCounter.calledCount shouldBe works.size

                  assertMetricCount(
                    metrics = metrics,
                    metricName = s"$namespace/Successful",
                    expectedCount = works.size
                  )
                  assertMetricDurations(
                    metrics = metrics,
                    metricName = s"$namespace/Duration",
                    expectedNumberDurations = works.size
                  )

                  assertQueueEmpty(queue)
                  assertQueueEmpty(dlq)
                }
            }
          }
      }
    }

    it(
      "records a failure if it can't process a message, then deletes the message") {
      withLocalSqsQueuePair() {
        case QueuePair(queue, dlq) =>
          withActorSystem { implicit actorSystem =>
            withPekkoSQSWorker(queue, terminalFailure, namespace) {
              case (worker, _, metrics, callCounter) =>
                worker.start

                val myWork = MyWork("my-new-work")

                sendNotificationToSQS(queue, myWork)

                eventually {
                  callCounter.calledCount shouldBe 1

                  assertMetricCount(
                    metrics = metrics,
                    metricName = s"$namespace/TerminalFailure",
                    expectedCount = 1
                  )
                  assertMetricDurations(
                    metrics = metrics,
                    metricName = s"$namespace/Duration",
                    expectedNumberDurations = 1
                  )

                  assertQueueEmpty(queue)
                  assertQueueEmpty(dlq)
                }
            }
          }
      }
    }

    it("retries a retryable failure three times, then DLQs the message") {
      withLocalSqsQueuePair() {
        case QueuePair(queue, dlq) =>
          withActorSystem { implicit actorSystem =>
            withPekkoSQSWorker(queue, retryableFailure, namespace) {
              case (worker, _, metrics, callCounter) =>
                worker.start

                val myWork = MyWork("my-new-work")

                sendNotificationToSQS(queue, myWork)

                eventually {
                  callCounter.calledCount shouldBe 3

                  assertMetricCount(
                    metrics = metrics,
                    metricName = s"$namespace/RetryableFailure",
                    expectedCount = 3
                  )
                  assertMetricDurations(
                    metrics = metrics,
                    metricName = s"$namespace/Duration",
                    expectedNumberDurations = 3
                  )

                  assertQueueEmpty(queue)
                  assertQueueHasSize(dlq, size = 1)
                }
            }
          }
      }
    }

    it("retries a terminal failure if it matches a known flaky exception") {
      val terminalFailure = (_: MyWork) =>
        TerminalFailure[MySummary](
          failure = new SocketTimeoutException("BOOM"),
          summary = Some("Got a timeout exception, oops")
      )

      withLocalSqsQueuePair() {
        case QueuePair(queue, dlq) =>
          withActorSystem { implicit actorSystem =>
            withPekkoSQSWorker(queue, terminalFailure, namespace) {
              case (worker, _, metrics, callCounter) =>
                worker.start

                val myWork = MyWork("my-new-work")

                sendNotificationToSQS(queue, myWork)

                eventually {
                  callCounter.calledCount shouldBe 3

                  assertMetricCount(
                    metrics = metrics,
                    metricName = s"$namespace/TerminalFailure",
                    expectedCount = 3
                  )
                  assertMetricDurations(
                    metrics = metrics,
                    metricName = s"$namespace/Duration",
                    expectedNumberDurations = 3
                  )

                  assertQueueEmpty(queue)
                  assertQueueHasSize(dlq, size = 1)
                }
            }
          }
      }
    }
  }

  describe("unparseable messages are recorded and deleted") {
    it("if they're not JSON") {
      withLocalSqsQueuePair() {
        case QueuePair(queue, dlq) =>
          withActorSystem { implicit actorSystem =>
            withPekkoSQSWorker(queue, successful, namespace) {
              case (worker, _, metrics, _) =>
                worker.start

                sendNotificationToSQS(queue, "not json")

                eventually {
                  assertMetricCount(
                    metrics = metrics,
                    metricName = s"$namespace/TerminalFailure",
                    expectedCount = 1
                  )
                  assertMetricDurations(
                    metrics = metrics,
                    metricName = s"$namespace/Duration",
                    expectedNumberDurations = 1
                  )

                  assertQueueEmpty(queue)
                  assertQueueEmpty(dlq)
                }
            }
          }
      }
    }

    it("if they can't be parsed") {
      withLocalSqsQueuePair() {
        case QueuePair(queue, dlq) =>
          withActorSystem { implicit actorSystem =>
            withPekkoSQSWorker(queue, successful, namespace) {
              case (worker, _, metrics, _) =>
                worker.start

                sendNotificationToSQS(
                  queue,
                  """{"json" : "but not the right format"}""")

                eventually {
                  assertMetricCount(
                    metrics = metrics,
                    metricName = s"$namespace/TerminalFailure",
                    expectedCount = 1
                  )
                  assertMetricDurations(
                    metrics = metrics,
                    metricName = s"$namespace/Duration",
                    expectedNumberDurations = 1
                  )

                  assertQueueEmpty(queue)
                  assertQueueEmpty(dlq)
                }
            }
          }
      }
    }
  }
}
